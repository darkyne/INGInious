#! /bin/python3.6
# -*- coding: utf-8 -*-
#
# This file is part of INGInious. See the LICENSE and the COPYRIGHTS files for
# more information about the licensing of this file.
import os
import shlex
import socket
import subprocess
import threading
import msgpack
import array
import asyncio
import sys
import struct
import logging

import time
import zmq
import zmq.asyncio

from inginious_container_api.utils import set_limits_user, start_ssh_server, ssh_wait, User


def handle_signals(subprocess, socket):
    """ Handles signals given by run_student on the socket """
    while True:
        signal = socket.recv(3)
        if signal == b'---' or len(signal) < 3: # quit
            return
        print("received %s" % signal.decode("utf8"))
        subprocess.send_signal(int(signal.decode('utf8')))



async def stdio():
    my_loop = asyncio.get_event_loop()
    reader = asyncio.StreamReader()
    reader_protocol = asyncio.StreamReaderProtocol(reader)
    #writer_transport, writer_protocol = await loop.connect_write_pipe(asyncio.streams.FlowControlMixin, os.fdopen(1, 'wb'))
    #writer = asyncio.StreamWriter(writer_transport, writer_protocol, None, loop)
    await my_loop.connect_read_pipe(lambda: reader_protocol, sys.stdin)
    return reader #, writer


async def handle_stdin():
    try:
        file = open("test.txt", "x")
        file.write("test")
        file.close()
        reader = await stdio()
        file = open("listening.txt", "x")
        file.write("listening")
        file.close()
        # reader, writer = await stdio()
        while not reader.at_eof():
            buf = bytearray()
            while len(buf) != 4 and not reader.at_eof():
                buf += await reader.read(4 - len(buf))
            if reader.at_eof():
                continue
            length = struct.unpack('I', bytes(buf))[0]
            buf = bytearray()
            while len(buf) != length and not reader.at_eof():
                buf += await reader.read(length - len(buf))
            if reader.at_eof():
                continue
            file = open("received.txt", "x")
            file.write("received")
            file.close()
            return msgpack.unpackb(bytes(buf), use_list=False)

    except (asyncio.CancelledError, KeyboardInterrupt):
        return
    except:
        exit(1)  # DIE!


async def main():

    f = open("file_from_inside.txt", "x")
    f.write("TEST")
    logger.info("Hello")
    f.write("1")
    # stdin, stdout = await stdio()
    f.write("2")
    f.close()
    time.sleep(60)

    """
    f.write("3")
    print("The command I received inside student_container:", flush=True)
    print(start_cmd)
    user = start_cmd["user"]
    f.write("4")
    f.close()
    time.sleep(60)
    """


###############################
# BODY ########################
###############################

logger = logging.getLogger("student")

# Start main()
context = zmq.asyncio.Context()
loop = zmq.asyncio.ZMQEventLoop()
asyncio.set_event_loop(loop)
loop.create_task(handle_stdin())
loop.run_until_complete(main())
loop.close()
context.destroy(1)


exit("ok")

"""
time.sleep(60)
#After that I'll crash since it will try the older version



# Connect to the socket
client = socket.socket(socket.AF_UNIX)  # , socket.SOCK_CLOEXEC) # for linux only
client.connect("/__parent.sock")

# Say hello
print("Saying hello")
client.send(b'H')
print("Said hello")

# Receive fds
print("Receiving fds")
msg, fds = recv_fds(client, 1, 3)
assert msg == b'S'
print("Received fds")

# Unpack the start message # TODO: it's ugly
print("Unpacking start cmd")
unpacker = msgpack.Unpacker()
start_cmd = None
while start_cmd is None:
    s = client.recv(1)
    unpacker.feed(s)
    for obj in unpacker:
        start_cmd = obj
print("Unpacked start cmd")
user = start_cmd["user"]  # Know if you are worker (on docker) or root (on Kata)

# Add some elements to /etc/hosts and /etc/resolv.conf if needed
system_files = {"hosts": ("/etc/hosts", True), "resolv.conf": ("/etc/resolv.conf", False)}
for name, (spath, append) in system_files.items():
    if os.path.exists(os.path.join('/task/systemfiles/', name)):
        try:
            open(spath, 'ab' if append else 'wb').write(b'\n' + open(os.path.join('/task/systemfiles/', name), 'rb').read())
        except IOError:
            exit(254)

# Start the process
print("Chdir")
os.chdir(start_cmd["working_dir"])
print("Popen")
print(fds)

set_limits = lambda: set_limits_user(user)  # To know if the command should be executed as root or worker
if start_cmd["command"] is None or start_cmd["command"] == "":  # Avoid to ron an empty command
    start_cmd["command"] = "echo 'info: student container started with no command set' "

# Run the command
p = subprocess.Popen(shlex.split(start_cmd["command"]), preexec_fn=set_limits, stdin=fds[0], stdout=fds[1], stderr=fds[2])
# Handle the signals
print("Signal thread")
thread = threading.Thread(target=lambda: handle_signals(p, client), daemon=True)
thread.start()
# Wait until the subprocess exit
print("Waiting for process to end")
retval = p.wait()

if start_cmd["ssh"]:
    # Start ssh server
    ssh_user, password = start_ssh_server(user)
    # Send ssh information
    ssh_user_bin = User[ssh_user].value  # 0 for root, 1 for worker
    message = msgpack.dumps({"type": "ssh_student", "ssh_user": ssh_user_bin, "password": password})  # constant size
    client.send(message)
    # Wait for user to connect and leave
    retval = ssh_wait(ssh_user)
    print("Exiting")
    exit(retval)
else:
    print("Exiting")
    exit(retval)
"""
